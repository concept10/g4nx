/* autogenerated by generator-pattern.js */

#include "../../debug.h"
#include "../../gi.h"
#include "../../util.h"
#include "path.h"
#include "pattern.h"
#include "matrix.h"
#include "surface.h"

using namespace v8;


namespace GNodeJS {

namespace Cairo {



Nan::Persistent<FunctionTemplate> Pattern::constructorTemplate;
Nan::Persistent<Function>         Pattern::constructor;


Nan::Persistent<FunctionTemplate> LinearPattern::constructorTemplate;
Nan::Persistent<Function>         LinearPattern::constructor;


Nan::Persistent<FunctionTemplate> RadialPattern::constructorTemplate;
Nan::Persistent<Function>         RadialPattern::constructor;


Nan::Persistent<FunctionTemplate> MeshPattern::constructorTemplate;
Nan::Persistent<Function>         MeshPattern::constructor;



/*
 * Initialize
 */

Pattern::Pattern(cairo_pattern_t* data) : ObjectWrap() {
  _data = data;
}

/*
 * Destroy
 */

Pattern::~Pattern() {
  if (_data != NULL) {
    cairo_pattern_destroy (_data);
  }
}


/*
 * Template methods
 */


Local<FunctionTemplate> Pattern::GetTemplate() {
  if (constructorTemplate.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<FunctionTemplate> (constructorTemplate);
}

Local<Function> Pattern::GetConstructor() {
  if (constructor.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<Function> (constructor);
}

void Pattern::SetupTemplate() {

  // Constructor
  auto tpl = Nan::New<FunctionTemplate>(Pattern::New);
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  tpl->SetClassName(Nan::New("CairoPattern").ToLocalChecked());


  SET_PROTOTYPE_METHOD(tpl, addColorStopRgb);
  SET_PROTOTYPE_METHOD(tpl, addColorStopRgba);
  SET_PROTOTYPE_METHOD(tpl, getColorStopCount);
  SET_PROTOTYPE_METHOD(tpl, getColorStopRgba);
  SET_PROTOTYPE_METHOD(tpl, getRgba);
  SET_PROTOTYPE_METHOD(tpl, status);
  SET_PROTOTYPE_METHOD(tpl, setExtend);
  SET_PROTOTYPE_METHOD(tpl, getExtend);
  SET_PROTOTYPE_METHOD(tpl, setFilter);
  SET_PROTOTYPE_METHOD(tpl, getFilter);
  SET_PROTOTYPE_METHOD(tpl, setMatrix);
  SET_PROTOTYPE_METHOD(tpl, getMatrix);
  SET_PROTOTYPE_METHOD(tpl, getType);
  SET_PROTOTYPE_METHOD(tpl, getReferenceCount);

  auto ctor = Nan::GetFunction (tpl).ToLocalChecked();

  SET_METHOD(ctor, createRgb);
  SET_METHOD(ctor, createRgba);
  SET_METHOD(ctor, createRadial);
  SET_METHOD(ctor, createMesh);
  SET_METHOD(ctor, createLinear);
  SET_METHOD(ctor, createForSurface);

  constructorTemplate.Reset(tpl);
  constructor.Reset(ctor);


  LinearPattern::SetupTemplate(tpl);
  RadialPattern::SetupTemplate(tpl);
  MeshPattern::SetupTemplate(tpl);
}


Local<FunctionTemplate> LinearPattern::GetTemplate() {
  if (constructorTemplate.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<FunctionTemplate> (constructorTemplate);
}

Local<Function> LinearPattern::GetConstructor() {
  if (constructor.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<Function> (constructor);
}

void LinearPattern::SetupTemplate(Local<FunctionTemplate> parentTpl) {

  // Constructor
  auto tpl = Nan::New<FunctionTemplate>(LinearPattern::New);
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  tpl->SetClassName(Nan::New("CairoLinearPattern").ToLocalChecked());
  tpl->Inherit (parentTpl);

  SET_PROTOTYPE_METHOD(tpl, getLinearPoints);

  auto ctor = Nan::GetFunction (tpl).ToLocalChecked();



  constructorTemplate.Reset(tpl);
  constructor.Reset(ctor);

}


Local<FunctionTemplate> RadialPattern::GetTemplate() {
  if (constructorTemplate.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<FunctionTemplate> (constructorTemplate);
}

Local<Function> RadialPattern::GetConstructor() {
  if (constructor.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<Function> (constructor);
}

void RadialPattern::SetupTemplate(Local<FunctionTemplate> parentTpl) {

  // Constructor
  auto tpl = Nan::New<FunctionTemplate>(RadialPattern::New);
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  tpl->SetClassName(Nan::New("CairoRadialPattern").ToLocalChecked());
  tpl->Inherit (parentTpl);

  SET_PROTOTYPE_METHOD(tpl, getRadialCircles);

  auto ctor = Nan::GetFunction (tpl).ToLocalChecked();



  constructorTemplate.Reset(tpl);
  constructor.Reset(ctor);

}


Local<FunctionTemplate> MeshPattern::GetTemplate() {
  if (constructorTemplate.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<FunctionTemplate> (constructorTemplate);
}

Local<Function> MeshPattern::GetConstructor() {
  if (constructor.IsEmpty())
    Pattern::SetupTemplate();
  return Nan::New<Function> (constructor);
}

void MeshPattern::SetupTemplate(Local<FunctionTemplate> parentTpl) {

  // Constructor
  auto tpl = Nan::New<FunctionTemplate>(MeshPattern::New);
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  tpl->SetClassName(Nan::New("CairoMeshPattern").ToLocalChecked());
  tpl->Inherit (parentTpl);

  SET_PROTOTYPE_METHOD(tpl, beginPatch);
  SET_PROTOTYPE_METHOD(tpl, endPatch);
  SET_PROTOTYPE_METHOD(tpl, moveTo);
  SET_PROTOTYPE_METHOD(tpl, lineTo);
  SET_PROTOTYPE_METHOD(tpl, curveTo);
  SET_PROTOTYPE_METHOD(tpl, setControlPoint);
  SET_PROTOTYPE_METHOD(tpl, setCornerColorRgb);
  SET_PROTOTYPE_METHOD(tpl, setCornerColorRgba);
  SET_PROTOTYPE_METHOD(tpl, getPatchCount);
  SET_PROTOTYPE_METHOD(tpl, getPath);
  SET_PROTOTYPE_METHOD(tpl, getControlPoint);
  SET_PROTOTYPE_METHOD(tpl, getCornerColorRgba);

  auto ctor = Nan::GetFunction (tpl).ToLocalChecked();



  constructorTemplate.Reset(tpl);
  constructor.Reset(ctor);

}



/*
 * Initialize method
 */


void Pattern::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::Set (target, Nan::New ("Pattern").ToLocalChecked(), Pattern::GetConstructor());
  Nan::Set (target, Nan::New ("LinearPattern").ToLocalChecked(), LinearPattern::GetConstructor());
  Nan::Set (target, Nan::New ("RadialPattern").ToLocalChecked(), RadialPattern::GetConstructor());
  Nan::Set (target, Nan::New ("MeshPattern").ToLocalChecked(), MeshPattern::GetConstructor());
}



/*
 * Instance constructors
 */



NAN_METHOD(Pattern::New) {
  if (!info.IsConstructCall()) {
    return Nan::ThrowTypeError("Class constructors cannot be invoked without 'new'");
  }

  cairo_pattern_t* data = NULL;

  if (info[0]->IsExternal()) {
    data = (cairo_pattern_t*) External::Cast (*info[0])->Value ();
  }
  else {
    return Nan::ThrowError("Cannot instantiate Pattern: use static creators");
  }

  Pattern* instance = new Pattern(data);
  instance->Wrap(info.This());

  info.GetReturnValue().Set(info.This());
}



NAN_METHOD(LinearPattern::New) {
  if (!info.IsConstructCall()) {
    return Nan::ThrowTypeError("Class constructors cannot be invoked without 'new'");
  }

  cairo_pattern_t* data = NULL;

  if (info[0]->IsExternal()) {
    data = (cairo_pattern_t*) External::Cast (*info[0])->Value ();
  }
  else {
    return Nan::ThrowError("Cannot instantiate LinearPattern: use static creators");
  }

  LinearPattern* instance = new LinearPattern(data);
  instance->Wrap(info.This());

  info.GetReturnValue().Set(info.This());
}



NAN_METHOD(RadialPattern::New) {
  if (!info.IsConstructCall()) {
    return Nan::ThrowTypeError("Class constructors cannot be invoked without 'new'");
  }

  cairo_pattern_t* data = NULL;

  if (info[0]->IsExternal()) {
    data = (cairo_pattern_t*) External::Cast (*info[0])->Value ();
  }
  else {
    return Nan::ThrowError("Cannot instantiate RadialPattern: use static creators");
  }

  RadialPattern* instance = new RadialPattern(data);
  instance->Wrap(info.This());

  info.GetReturnValue().Set(info.This());
}



NAN_METHOD(MeshPattern::New) {
  if (!info.IsConstructCall()) {
    return Nan::ThrowTypeError("Class constructors cannot be invoked without 'new'");
  }

  cairo_pattern_t* data = NULL;

  if (info[0]->IsExternal()) {
    data = (cairo_pattern_t*) External::Cast (*info[0])->Value ();
  }
  else {
    return Nan::ThrowError("Cannot instantiate MeshPattern: use static creators");
  }

  MeshPattern* instance = new MeshPattern(data);
  instance->Wrap(info.This());

  info.GetReturnValue().Set(info.This());
}



/*
 * Methods
 */

NAN_METHOD(Pattern::createRgb) {
  // in-arguments
  auto red = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto green = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto blue = Nan::To<double>(info[2].As<Number>()).ToChecked();

  // function call
  cairo_pattern_t * result = cairo_pattern_create_rgb (red, green, blue);

  // return
  Local<Value> args[] = { Nan::New<External> (result) };
  Local<Function> constructor = Nan::New<Function> (Pattern::constructor);
  Local<Value> returnValue = Nan::NewInstance(constructor, 1, args).ToLocalChecked();
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::createRgba) {
  // in-arguments
  auto red = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto green = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto blue = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto alpha = Nan::To<double>(info[3].As<Number>()).ToChecked();

  // function call
  cairo_pattern_t * result = cairo_pattern_create_rgba (red, green, blue, alpha);

  // return
  Local<Value> args[] = { Nan::New<External> (result) };
  Local<Function> constructor = Nan::New<Function> (Pattern::constructor);
  Local<Value> returnValue = Nan::NewInstance(constructor, 1, args).ToLocalChecked();
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::createRadial) {
  // in-arguments
  auto cx0 = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto cy0 = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto radius0 = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto cx1 = Nan::To<double>(info[3].As<Number>()).ToChecked();
  auto cy1 = Nan::To<double>(info[4].As<Number>()).ToChecked();
  auto radius1 = Nan::To<double>(info[5].As<Number>()).ToChecked();

  // function call
  cairo_pattern_t * result = cairo_pattern_create_radial (cx0, cy0, radius0, cx1, cy1, radius1);

  // return
  Local<Value> args[] = { Nan::New<External> (result) };
  Local<Function> constructor = Nan::New<Function> (RadialPattern::constructor);
  Local<Value> returnValue = Nan::NewInstance(constructor, 1, args).ToLocalChecked();
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::createMesh) {
  // function call
  cairo_pattern_t * result = cairo_pattern_create_mesh ();

  // return
  Local<Value> args[] = { Nan::New<External> (result) };
  Local<Function> constructor = Nan::New<Function> (MeshPattern::constructor);
  Local<Value> returnValue = Nan::NewInstance(constructor, 1, args).ToLocalChecked();
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::createLinear) {
  // in-arguments
  auto x0 = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto y0 = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto x1 = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto y1 = Nan::To<double>(info[3].As<Number>()).ToChecked();

  // function call
  cairo_pattern_t * result = cairo_pattern_create_linear (x0, y0, x1, y1);

  // return
  Local<Value> args[] = { Nan::New<External> (result) };
  Local<Function> constructor = Nan::New<Function> (LinearPattern::constructor);
  Local<Value> returnValue = Nan::NewInstance(constructor, 1, args).ToLocalChecked();
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::createForSurface) {
  // in-arguments
  auto surface = Nan::ObjectWrap::Unwrap<Surface>(info[0].As<Object>())->_data;

  // function call
  cairo_pattern_t * result = cairo_pattern_create_for_surface (surface);

  // return
  Local<Value> args[] = { Nan::New<External> (result) };
  Local<Function> constructor = Nan::New<Function> (Pattern::constructor);
  Local<Value> returnValue = Nan::NewInstance(constructor, 1, args).ToLocalChecked();
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::addColorStopRgb) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // in-arguments
  auto offset = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto red = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto green = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto blue = Nan::To<double>(info[3].As<Number>()).ToChecked();

  // function call
  cairo_pattern_add_color_stop_rgb (pattern, offset, red, green, blue);
}

NAN_METHOD(Pattern::addColorStopRgba) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // in-arguments
  auto offset = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto red = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto green = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto blue = Nan::To<double>(info[3].As<Number>()).ToChecked();
  auto alpha = Nan::To<double>(info[4].As<Number>()).ToChecked();

  // function call
  cairo_pattern_add_color_stop_rgba (pattern, offset, red, green, blue, alpha);
}

NAN_METHOD(Pattern::getColorStopCount) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // out-arguments
  int count = 0;

  // function call
  cairo_status_t result = cairo_pattern_get_color_stop_count (pattern, &count);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("count"), Nan::New (count));
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::getColorStopRgba) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // in-arguments
  auto index = Nan::To<int64_t>(info[0].As<Number>()).ToChecked();

  // out-arguments
  double offset = 0.0;
  double red = 0.0;
  double green = 0.0;
  double blue = 0.0;
  double alpha = 0.0;

  // function call
  cairo_status_t result = cairo_pattern_get_color_stop_rgba (pattern, index, &offset, &red, &green, &blue, &alpha);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("offset"), Nan::New (offset));
  Nan::Set (returnValue, UTF8 ("red"), Nan::New (red));
  Nan::Set (returnValue, UTF8 ("green"), Nan::New (green));
  Nan::Set (returnValue, UTF8 ("blue"), Nan::New (blue));
  Nan::Set (returnValue, UTF8 ("alpha"), Nan::New (alpha));
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::getRgba) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // out-arguments
  double red = 0.0;
  double green = 0.0;
  double blue = 0.0;
  double alpha = 0.0;

  // function call
  cairo_status_t result = cairo_pattern_get_rgba (pattern, &red, &green, &blue, &alpha);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("red"), Nan::New (red));
  Nan::Set (returnValue, UTF8 ("green"), Nan::New (green));
  Nan::Set (returnValue, UTF8 ("blue"), Nan::New (blue));
  Nan::Set (returnValue, UTF8 ("alpha"), Nan::New (alpha));
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::status) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // function call
  cairo_status_t result = cairo_pattern_status (pattern);

  // return
  Local<Value> returnValue = Nan::New (result);
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::setExtend) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // in-arguments
  auto extend = (cairo_extend_t) Nan::To<int64_t>(info[0].As<Number>()).ToChecked();

  // function call
  cairo_pattern_set_extend (pattern, extend);
}

NAN_METHOD(Pattern::getExtend) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // function call
  cairo_extend_t result = cairo_pattern_get_extend (pattern);

  // return
  Local<Value> returnValue = Nan::New (result);
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::setFilter) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // in-arguments
  auto filter = (cairo_filter_t) Nan::To<int64_t>(info[0].As<Number>()).ToChecked();

  // function call
  cairo_pattern_set_filter (pattern, filter);
}

NAN_METHOD(Pattern::getFilter) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // function call
  cairo_filter_t result = cairo_pattern_get_filter (pattern);

  // return
  Local<Value> returnValue = Nan::New (result);
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::setMatrix) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // in-arguments
  auto matrix = Nan::ObjectWrap::Unwrap<Matrix>(info[0].As<Object>())->_data;

  // function call
  cairo_pattern_set_matrix (pattern, matrix);
}

NAN_METHOD(Pattern::getMatrix) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // out-arguments
  auto matrix = Nan::NewInstance(
            Nan::New<Function>(Matrix::constructor),
            0,
            NULL).ToLocalChecked();

  // function call
  cairo_pattern_get_matrix (pattern, Nan::ObjectWrap::Unwrap<Matrix>(matrix)->_data);

  // return
  Local<Value> returnValue = matrix;
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::getType) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // function call
  cairo_pattern_type_t result = cairo_pattern_get_type (pattern);

  // return
  Local<Value> returnValue = Nan::New (result);
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(Pattern::getReferenceCount) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<Pattern>(self)->_data;

  // function call
  unsigned int result = cairo_pattern_get_reference_count (pattern);

  // return
  Local<Value> returnValue = Nan::New (result);
  info.GetReturnValue().Set(returnValue);
}
NAN_METHOD(LinearPattern::getLinearPoints) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<LinearPattern>(self)->_data;

  // out-arguments
  double x0 = 0.0;
  double y0 = 0.0;
  double x1 = 0.0;
  double y1 = 0.0;

  // function call
  cairo_status_t result = cairo_pattern_get_linear_points (pattern, &x0, &y0, &x1, &y1);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("x0"), Nan::New (x0));
  Nan::Set (returnValue, UTF8 ("y0"), Nan::New (y0));
  Nan::Set (returnValue, UTF8 ("x1"), Nan::New (x1));
  Nan::Set (returnValue, UTF8 ("y1"), Nan::New (y1));
  info.GetReturnValue().Set(returnValue);
}
NAN_METHOD(RadialPattern::getRadialCircles) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<RadialPattern>(self)->_data;

  // out-arguments
  double x0 = 0.0;
  double y0 = 0.0;
  double r0 = 0.0;
  double x1 = 0.0;
  double y1 = 0.0;
  double r1 = 0.0;

  // function call
  cairo_status_t result = cairo_pattern_get_radial_circles (pattern, &x0, &y0, &r0, &x1, &y1, &r1);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("x0"), Nan::New (x0));
  Nan::Set (returnValue, UTF8 ("y0"), Nan::New (y0));
  Nan::Set (returnValue, UTF8 ("r0"), Nan::New (r0));
  Nan::Set (returnValue, UTF8 ("x1"), Nan::New (x1));
  Nan::Set (returnValue, UTF8 ("y1"), Nan::New (y1));
  Nan::Set (returnValue, UTF8 ("r1"), Nan::New (r1));
  info.GetReturnValue().Set(returnValue);
}
NAN_METHOD(MeshPattern::beginPatch) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // function call
  cairo_mesh_pattern_begin_patch (pattern);
}

NAN_METHOD(MeshPattern::endPatch) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // function call
  cairo_mesh_pattern_end_patch (pattern);
}

NAN_METHOD(MeshPattern::moveTo) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto x = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto y = Nan::To<double>(info[1].As<Number>()).ToChecked();

  // function call
  cairo_mesh_pattern_move_to (pattern, x, y);
}

NAN_METHOD(MeshPattern::lineTo) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto x = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto y = Nan::To<double>(info[1].As<Number>()).ToChecked();

  // function call
  cairo_mesh_pattern_line_to (pattern, x, y);
}

NAN_METHOD(MeshPattern::curveTo) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto x1 = Nan::To<double>(info[0].As<Number>()).ToChecked();
  auto y1 = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto x2 = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto y2 = Nan::To<double>(info[3].As<Number>()).ToChecked();
  auto x3 = Nan::To<double>(info[4].As<Number>()).ToChecked();
  auto y3 = Nan::To<double>(info[5].As<Number>()).ToChecked();

  // function call
  cairo_mesh_pattern_curve_to (pattern, x1, y1, x2, y2, x3, y3);
}

NAN_METHOD(MeshPattern::setControlPoint) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto point_num = Nan::To<int64_t>(info[0].As<Number>()).ToChecked();
  auto x = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto y = Nan::To<double>(info[2].As<Number>()).ToChecked();

  // function call
  cairo_mesh_pattern_set_control_point (pattern, point_num, x, y);
}

NAN_METHOD(MeshPattern::setCornerColorRgb) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto corner_num = Nan::To<int64_t>(info[0].As<Number>()).ToChecked();
  auto red = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto green = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto blue = Nan::To<double>(info[3].As<Number>()).ToChecked();

  // function call
  cairo_mesh_pattern_set_corner_color_rgb (pattern, corner_num, red, green, blue);
}

NAN_METHOD(MeshPattern::setCornerColorRgba) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto corner_num = Nan::To<int64_t>(info[0].As<Number>()).ToChecked();
  auto red = Nan::To<double>(info[1].As<Number>()).ToChecked();
  auto green = Nan::To<double>(info[2].As<Number>()).ToChecked();
  auto blue = Nan::To<double>(info[3].As<Number>()).ToChecked();
  auto alpha = Nan::To<double>(info[4].As<Number>()).ToChecked();

  // function call
  cairo_mesh_pattern_set_corner_color_rgba (pattern, corner_num, red, green, blue, alpha);
}

NAN_METHOD(MeshPattern::getPatchCount) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // out-arguments
  unsigned int count = 0;

  // function call
  cairo_status_t result = cairo_mesh_pattern_get_patch_count (pattern, &count);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("count"), Nan::New (count));
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(MeshPattern::getPath) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto patch_num = Nan::To<int64_t>(info[0].As<Number>()).ToChecked();

  // function call
  cairo_path_t * result = cairo_mesh_pattern_get_path (pattern, patch_num);

  // return
  Local<Value> args[] = { Nan::New<External> (result) };
  Local<Function> constructor = Nan::New<Function> (Path::constructor);
  Local<Value> returnValue = Nan::NewInstance(constructor, 1, args).ToLocalChecked();
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(MeshPattern::getControlPoint) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto patch_num = Nan::To<int64_t>(info[0].As<Number>()).ToChecked();
  auto point_num = Nan::To<int64_t>(info[1].As<Number>()).ToChecked();

  // out-arguments
  double x = 0.0;
  double y = 0.0;

  // function call
  cairo_status_t result = cairo_mesh_pattern_get_control_point (pattern, patch_num, point_num, &x, &y);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("x"), Nan::New (x));
  Nan::Set (returnValue, UTF8 ("y"), Nan::New (y));
  info.GetReturnValue().Set(returnValue);
}

NAN_METHOD(MeshPattern::getCornerColorRgba) {
  auto self = info.This();
  auto pattern = Nan::ObjectWrap::Unwrap<MeshPattern>(self)->_data;

  // in-arguments
  auto patch_num = Nan::To<int64_t>(info[0].As<Number>()).ToChecked();
  auto corner_num = Nan::To<int64_t>(info[1].As<Number>()).ToChecked();

  // out-arguments
  double red = 0.0;
  double green = 0.0;
  double blue = 0.0;
  double alpha = 0.0;

  // function call
  cairo_status_t result = cairo_mesh_pattern_get_corner_color_rgba (pattern, patch_num, corner_num, &red, &green, &blue, &alpha);

  // return
  Local<Object> returnValue = Nan::New<Object> ();
  Nan::Set (returnValue, UTF8 ("red"), Nan::New (red));
  Nan::Set (returnValue, UTF8 ("green"), Nan::New (green));
  Nan::Set (returnValue, UTF8 ("blue"), Nan::New (blue));
  Nan::Set (returnValue, UTF8 ("alpha"), Nan::New (alpha));
  info.GetReturnValue().Set(returnValue);
}



}; // Cairo

}; // GNodeJS